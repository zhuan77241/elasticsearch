[[tune-for-disk-usage]]
== 磁盘调优方式

[float]
=== 禁用您不需要的功能

默认情况下，Elasticsearch 会对大多数字段进行索引并添加 doc values，以便可以直接搜索和聚合它们。 例如，如果你有一个名为`foo`的数字字段，你需要运行直方图但你永远不需要过滤，
你可以安全地禁用你的这个字段的索引通过 <<mappings,mappings>>:

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "foo": {
          "type": "integer",
          "index": false
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<<text,`text`>> 字段存储索引中的规范化因子，以便能够对文档进行评分。 如果你只需要 `text` 字段的匹配功能
而不关心产生的分数，您可以配置 Elasticsearch 不向索引写入 norms ：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "foo": {
          "type": "text",
          "norms": false
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

<<text,`text`>> 字段默认存储索引中的频率和位置。
频率用于计算分数，位置用于运行短语查询。
如果您不需要运行短语查询，则可以告诉 Elasticsearch 不用索引位置：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "foo": {
          "type": "text",
          "index_options": "freqs"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

此外，如果你不关心评分，你可以配置 Elasticsearch 只为每个词项索引匹配文档。 您仍然可以搜索此字段，但短语查询会引发错误，评分将假定词项在每个文档中只出现一次。

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "properties": {
        "foo": {
          "type": "text",
          "norms": false,
          "index_options": "freqs"
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 不要使用默认动态字符串映射

默认的 <<dynamic-mapping,dynamic string mappings>> 将字符串字段同时索引为 <<text,`text`>> 和 <<keyword,`keyword`>>。
如果您只需要其中一个，那就太浪费了。通常，`id` 字段只需要被索引为 `keyword`，而 `body` 字段只需要被索引为 `text` 字段。

可以通过在字符串字段上配置显式映射或设置将字符串字段映射为 `text` 或 `keyword` 的动态模板来禁用此功能。

例如一下这个模板，可以用于仅将字符串字段映射为 `keyword`：

[source,js]
--------------------------------------------------
PUT index
{
  "mappings": {
    "_doc": {
      "dynamic_templates": [
        {
          "strings": {
            "match_mapping_type": "string",
            "mapping": {
              "type": "keyword"
            }
          }
        }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE

[float]
=== 观察您的分片大小

Larger shards are going to be more efficient at storing data. To increase the size of your shards, you can decrease the number of primary shards in an index by <<indices-create-index,creating indices>> with less primary shards, creating less indices (e.g. by leveraging the <<indices-rollover-index,Rollover API>>), or modifying an existing index using the <<indices-shrink-index,Shrink API>>.
较大的分片在存储数据方面会更有效。
要增加分片的大小，可以通过 <<indices-create-index,creating indices>> 来减少索引中主分片的数量，
创建较少分片的索引（例如，通过利用 <<indices-rollover-index,Rollover API>> ），或使用 <<indices-shrink-index,Shrink API>> 修改现有索引。

请记住，大的分片也有缺点，例如恢复分片时间会更长。

[float]
=== 关闭 `_all`

<<mapping-all-field,`_all`>> 字段索引文档的所有字段的值，占用大量空间。 如果您不需要同时搜索所有字段，则可以禁用它。

[float]
=== 关闭 `_source`

<<mapping-source-field,`_source`>> 字段存储文档的原始 JSON 主体。 如果您不需要访问它，您可以禁用它。 但是，需要访问 `_source` 的 API（如 update 和 reindex ）将不起作用。

[float]
=== 使用 `best_compression`

`_source` 和存储字段很容易占用不可忽略的磁盘空间。 通过使用 `best_compression` <<index-codec,codec>> 可以更高效的压缩它们。

[float]
=== 强制合并

Elasticsearch 中的索引存储在一个或多个分片中。 每个分片都是一个 Lucene 索引，由一个或多个段组成 - 磁盘上的实际文件。 较大的段文件能更有效的存储数据。

<<indices-forcemerge,`_forcemerge` API>> 可用于减少每个分片的段总数。 在许多情况下，通过设置 `max_num_segments=1`，可以将每个分片的段总数减少到一个。

[float]
=== Shrink Index

<<indices-shrink-index,Shrink API>> 允许您减少索引中的分片数。 与上面的 Force Merge API 一起，这可以显着减少索引中的分片和段的数量。

[float]
=== 使用恰好满足的最小数字类型

您为 <<number,numeric data>> 选择的类型会对磁盘使用量产生重大影响。 特别是，整数应该使用整数类型 (`byte`, `short`, `integer` or `long`)存储，浮点应该存储在 `scaled_float` 中，如果合适的话，或者存储在适合的最小类型中。 用例：在 `double` 上使用 `float` ，或在 `float` 上使用 `half_float` 将有助于节省存储空间。

[float]
=== 使用索引排序来合并类似的文档

当 Elasticsearch 存储 `_source` 时，它会一次压缩多个文档，以提高整体压缩比。 例如，文档共享相同的字段名称是非常常见的，并且它们共享一些字段值非常常见，尤其是在基数较低的字段或 https://en.wikipedia.org/wiki/Zipf%27s_law[zipfian] 分布。

默认情况下，文档按照添加到索引的顺序压缩在一起。 如果您启用了 <<index-modules-index-sorting,index sorting>>，那么它们将按排序顺序进行压缩。 对具有相似结构，字段和值的文档进行排序可以提高压缩比。

[float]
=== 在文档中以相同的顺序放置字段

由于多个文档被压缩成块，因此如果字段总是以相同的顺序出现，则更有可能在那些 `_source` 文档中找到更长的重复字符串。
